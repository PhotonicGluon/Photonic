---
import { readFileSync } from "fs";

// Set up properties of the component
export interface Props {
    /** ID of the element */
    id: string;
    /** URL to the fragment shader */
    fragURL: string;
    /**
     * Optional URL to a typescript file containing editable uniforms.
     *
     * Do **not** include a leading slash (i.e., follow the format used by `fragURL`).
     */
    editableUniformsURL?: string;
    /**
     * Optional shader constants.
     *
     * These constants are meant to be passed into the shader once.
     */
    constants?: { [name: string]: any };
}

const { id, fragURL, editableUniformsURL, constants } = Astro.props;

// Get fragment shader code
const shaderFrag: string = readFileSync(fragURL, "utf-8");

// Get editable uniforms
let editableUniforms;
if (editableUniformsURL && !import.meta.env.PROD) {
    editableUniforms = (await import(/* @vite-ignore */ "/" + editableUniformsURL)).editableUniforms;
} else {
    editableUniforms = {};
}
---

<canvas
    class="shader"
    id={id}
    data-shader-url={fragURL}
    data-shader-frag={shaderFrag}
    data-constants={JSON.stringify(constants)}
    data-editable-uniforms={JSON.stringify(editableUniforms)}></canvas>

<style>
    .shader {
        @apply h-[inherit] w-full;
    }
</style>

<script>
    /**
     * Partially adapted from
     * https://github.com/s-thom/website-2023/blob/26d8a1a/src/components/site/ShaderBackdrop.astro.
     */

    import { setupShader } from "@lib/shaders/setup";
    import shaderVert from "@lib/shaders/2d.vert";
    import type { SlidersInitialisedEvent } from "@lib/tweakpane/panel";
    import type { SlidersOptionsMap } from "@lib/tweakpane/options";

    // Process each canvas
    document.querySelectorAll(".shader").forEach((element) => {
        // Cast the element as a canvas element
        const canvas = element as HTMLCanvasElement;

        // Get fragment shader
        const shaderFrag = canvas.dataset.shaderFrag;
        if (!shaderFrag) {
            throw Error("No fragment shader given");
        }
        delete canvas.dataset.shaderFrag; // No need to keep it now that we have it

        // Get shader constants
        let constants: { [name: string]: any };
        if (canvas.dataset.constants) {
            constants = JSON.parse(canvas.dataset.constants);
        } else {
            constants = {};
        }
        delete canvas.dataset.constants;

        // Define editable uniforms
        let editableUniforms: SlidersOptionsMap;
        if (canvas.dataset.editableUniforms) {
            editableUniforms = JSON.parse(canvas.dataset.editableUniforms);
        } else {
            editableUniforms = {};
        }
        delete canvas.dataset.editableUniforms;

        window.addEventListener("sliders-initialised", ((event: InstanceType<typeof SlidersInitialisedEvent>) => {
            event.detail.registerSliders(canvas.id, editableUniforms);
        }) as (e: Event) => void);

        // Define uniforms
        const uniforms: Record<string, any> = {};

        for (const [key, value] of Object.entries(constants)) {
            uniforms[key] = value;
        }

        // Set up shader
        const { start, stop } = setupShader({
            canvas,
            sources: { vertex: shaderVert, fragment: shaderFrag },
            uniforms,
            onFrame: (time) => {
                // Update pixel density
                uniforms.uPixelDensity = window.devicePixelRatio;

                // Update any editable uniforms
                for (const [key, value] of Object.entries(editableUniforms)) {
                    uniforms[key] = value.value;
                }

                // TODO: Handle reduced motion
                // if (time > 1) {
                //     stop();
                // }
            },
            textures: undefined,
            onTexturesReady: () => {
                start();
            },
        });

        start();
    });
</script>
