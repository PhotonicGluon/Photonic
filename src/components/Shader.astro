---
import { readFileSync } from "fs";
import seedrandom from "seedrandom";

// Set up properties of the component
export interface Props {
    /** ID of the element */
    id: string;
    /** URL to the fragment shader */
    fragURL: string;
    /**
     * Optional URL to a typescript file containing editable uniforms.
     *
     * Do **not** include a leading slash (i.e., follow the format used by `fragURL`).
     */
    editableUniformsURL?: string;
    /** Optional URL to the image that is used */
    imageURL?: string;
}

const { id, fragURL, editableUniformsURL, imageURL } = Astro.props;

// Get fragment shader code
const shaderFrag: string = readFileSync(fragURL, "utf-8");

// Get editable uniforms
let editableUniforms;
if (editableUniformsURL && !import.meta.env.PROD) {
    editableUniforms = (await import(/* @vite-ignore */ "/" + editableUniformsURL)).editableUniforms;
} else {
    editableUniforms = {};
}

// Define pseudo-random offset and scale of the image
let offset = [0, 0];
let scale = 1;
if (imageURL) {
    const random = seedrandom(id);
    offset = [Math.floor(random() * 21) - 10, Math.floor(random() * 21) - 10];
    scale = random() * 2 + 1;
}
---

<canvas
    class="shader"
    id={id}
    data-image-url={imageURL}
    data-shader-url={fragURL}
    data-shader-frag={shaderFrag}
    data-editable-uniforms={JSON.stringify(editableUniforms)}
    data-offset={JSON.stringify(offset)}
    data-warp-scale={JSON.stringify(scale)}></canvas>

<style>
    .shader {
        @apply h-[inherit] w-full;
    }
</style>

<script>
    /**
     * Partially adapted from
     * https://github.com/s-thom/website-2023/blob/26d8a1a/src/components/site/ShaderBackdrop.astro.
     */

    import { setupShader } from "@lib/shaders/setup";
    import { Interpolate, easeInOutCubic } from "@lib/shaders/interpolate";
    import shaderVert from "@lib/shaders/2d.vert";
    import type { SlidersInitialisedEvent } from "@lib/tweakpane/panel";
    import type { SlidersOptionsMap } from "@lib/tweakpane/options";

    // Process each canvas
    document.querySelectorAll(".shader").forEach((element) => {
        // Cast the element as a canvas element
        const canvas = element as HTMLCanvasElement;

        // Get fragment shader
        const shaderFrag = canvas.dataset.shaderFrag;
        if (!shaderFrag) {
            throw Error("No fragment shader given");
        }
        delete canvas.dataset.shaderFrag; // No need to keep it now that we have it

        // Get background
        const backgroundURL = canvas.dataset.imageUrl;
        const hasBackground = backgroundURL !== undefined;

        // Define editable uniforms
        let editableUniforms: SlidersOptionsMap;
        if (canvas.dataset.editableUniforms) {
            editableUniforms = JSON.parse(canvas.dataset.editableUniforms);
        } else {
            editableUniforms = {};
        }
        delete canvas.dataset.editableUniforms;

        window.addEventListener("sliders-initialised", ((event: InstanceType<typeof SlidersInitialisedEvent>) => {
            event.detail.registerSliders(canvas.id, editableUniforms);
        }) as (e: Event) => void);

        // Define uniforms
        const uniforms: Record<string, any> = {};

        uniforms.uUseColours = !hasBackground;

        uniforms.uWarpIter = hasBackground ? 4 : 9;
        uniforms.uOffset = canvas.dataset.offset ? JSON.parse(canvas.dataset.offset) : [0, 0];
        uniforms.uWarpScale = canvas.dataset.warpScale ? JSON.parse(canvas.dataset.warpScale) : 1;

        // Define interpolator
        const interpolator = new Interpolate(easeInOutCubic, hasBackground ? 0 : 1);

        // // Intersection observer for changing multiplier during scroll
        // let canvasIntersectionRatio = 1;
        // const observer = new IntersectionObserver(
        //     (entries) => {
        //         for (const entry of entries) {
        //             if (entry.target === canvas) {
        //                 canvasIntersectionRatio = entry.intersectionRatio;
        //             }
        //         }
        //     },
        //     {
        //         // Fire callback on many changes. 100 should be smooth enough.
        //         threshold: range(101).map((n) => n / 100),
        //     },
        // );
        // observer.observe(canvas);

        const { start, stop } = setupShader({
            canvas,
            sources: { vertex: shaderVert, fragment: shaderFrag },
            uniforms,
            onFrame: (time) => {
                // uniforms.uWarpAmount =
                //     ((1 - canvasIntersectionRatio) *
                //         (MAX_PAINT_FACTOR - MIN_PAINT_FACTOR) +
                //         MIN_PAINT_FACTOR) *
                //     interpolator.getValue();

                // Update pixel density
                uniforms.uPixelDensity = window.devicePixelRatio;

                // Update any editable uniforms
                for (const [key, value] of Object.entries(editableUniforms)) {
                    uniforms[key] = value.value;
                }

                // TODO: Handle reduced motion
                // if (time > 1) {
                //     stop();
                // }
            },
            textures: hasBackground ? [{ src: backgroundURL }] : undefined,
            onTexturesReady: () => {
                // interpolator.setTarget(prefersReducedMotion ? 0 : 1, 10_000);
                start();
            },
        });

        interpolator.on("start", ({ current }) => {
            if (current === 0) {
                start();
            }
        });
        interpolator.on("end", ({ current }) => {
            if (current === 0) {
                stop();
            }
        });

        if (!hasBackground) {
            start();
        }
    });
</script>
